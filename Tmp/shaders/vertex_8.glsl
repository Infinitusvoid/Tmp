

#version 450 core
layout(location = 0) in vec3 aPos;
layout(location = 1) in vec2 aTexCoord;

out vec2 TexCoord;
out vec3 color_vs;

// NEW: feed the FS
out vec3 vWorldPos;
out vec3 vNormal;

uniform mat4 model;       // can be identity
uniform mat4 view;
uniform mat4 projection;

// -------- Controls (few scalars only) --------
uniform ivec3 uGrid;      // number of instances along X,Y,Z (instanceCount = X*Y*Z)
uniform float uSpacing;   // distance between grid cells
uniform vec3  uOrigin;    // base world offset
uniform vec3  uScaleMin;  // min scale per axis
uniform vec3  uScaleMax;  // max scale per axis
uniform float uTime;      // time (seconds)
uniform float uRotSpeed;  // radians/sec
uniform uint  uSeed;      // global random seed

uniform uint uDrawcallNumber;
uniform vec3 uCameraPos;
uniform float u0, u1, u2, u3, u4, u5, u6, u7, u8, u9;

// ---------- Constants & tiny helpers ----------
const float PI = 3.1415926535897932384626433832795;
const float TAU = 6.2831853071795864769252867665590;

float saturate(float x) { return clamp(x, 0.0, 1.0); }

uint pcg_hash(uint x) {
    x = x * 747796405u + 2891336453u;
    x = ((x >> ((x >> 28u) + 4u)) ^ x) * 277803737u;
    x = (x >> 22u) ^ x;
    return x;
}
float rand01(inout uint s) { s = pcg_hash(s); return float(s) * (1.0 / 4294967295.0); }

vec3 spherical01(float r, float theta01, float phi01) {
    float theta = theta01 * TAU; // azimuth
    float phi = phi01 * PI;   // polar
    float sphi = sin(phi);
    return vec3(r * sphi * cos(theta), r * cos(phi), r * sphi * sin(theta));
}

mat3 axisAngleToMat3(vec3 axis, float a) {
    float c = cos(a), s = sin(a);
    vec3 t = (1.0 - c) * axis;
    return mat3(
        t.x * axis.x + c, t.x * axis.y - s * axis.z, t.x * axis.z + s * axis.y,
        t.y * axis.x + s * axis.z, t.y * axis.y + c, t.y * axis.z - s * axis.x,
        t.z * axis.x - s * axis.y, t.z * axis.y + s * axis.x, t.z * axis.z + c
    );
}

// Axis-aligned cube face normal from aPos (local space)
vec3 localCubeFaceNormal(vec3 p) {
    vec3 ap = abs(p);
    if (ap.x >= ap.y && ap.x >= ap.z) return vec3(sign(p.x), 0.0, 0.0);
    if (ap.y >= ap.x && ap.y >= ap.z) return vec3(0.0, sign(p.y), 0.0);
    return vec3(0.0, 0.0, sign(p.z));
}


// Height-only ocean: multi-band deep-water sine (no globals)
// x,y: world-space horizontal (meters); t: time (seconds)
float wave(float x, float y, float t)
{
    // ---------------- tunables (edit to taste) ----------------
    const int   OCTAVES = 6;        // number of wave bands (4..10)
    float       amp0 = 0.40;     // base amplitude of largest swell
    float       lambda0 = 80.0;     // largest wavelength (world units)
    float       lacunarity = 0.5;      // wavelength multiplier per octave (<1 shrinks)
    float       gain = 0.65;     // amplitude falloff per octave (0..1)
    vec2        windDir = normalize(vec2(0.85, 0.52)); // dominant travel dir
    float       dirJitter = 0.8;      // 0=all same dir, 1=spread via golden-angle turns
    float       timeScale = 1.0;      // playback speed
    float       heightScale = 1.0;      // final scale for the sum
    // -----------------------------------------------------------

    const float PI = 3.14159265358979323846;
    const float G = 9.81; // gravity

    vec2  p = vec2(x, y);
    float h = 0.0;

    // golden angle for nicely spaced directions
    const float GOLD = 2.399963229728653;

    for (int i = 0; i < OCTAVES; ++i) {
        float fi = float(i);

        // wavelength, wavenumber, dispersion
        float lambda = lambda0 * pow(lacunarity, fi);
        float k = 2.0 * PI / max(lambda, 1e-5);
        float omega = sqrt(G * k);

        // direction: rotate wind by jittered golden-angle steps
        float ang = fi * GOLD * dirJitter;
        float c = cos(ang), s = sin(ang);
        vec2  d = normalize(vec2(c * windDir.x - s * windDir.y,
            s * windDir.x + c * windDir.y));

        // amplitude for this octave
        float a = amp0 * pow(gain, fi);

        // de-synced phase
        float phi = k * dot(d, p) - omega * (timeScale * t) + fi * 1.234567;

        // accumulate vertical displacement
        h += a * sin(phi);
    }

    return h * heightScale;
}


// Autogenerated by Ocean Waves Param Explorer
// Composite ocean height  paste into your GLSL
float waves_combo_0(float x, float y, float t)
{
    const float PI = 3.14159265358979323846;
    const float G = 9.81;
    const float GOLD = 2.399963229728653;
    vec2 p = vec2(x, y);
    float h = 0.0; float wSum = 0.0;

    // Group A
    {
        const int OCT = 5;
        float amp0 = 0.6; float lambda0 = 131;
        float lacunarity = 0.55; float gain = 0.72;
        vec2 windDir = normalize(vec2(0.9659258262890683, 0.25881904510252074));
        float dirJitter = 0.77; float timeScale = 0.6;
        float peak = 0.64; float weight = 1;
        float hg = 0.0;
        for (int i = 0; i < OCT; ++i) {
            float fi = float(i);
            float lambda = lambda0 * pow(lacunarity, fi);
            float k = 2.0 * PI / max(lambda, 1e-5);
            float omega = sqrt(G * k);
            float ang = fi * GOLD * dirJitter + 0.0;
            float c = cos(ang), s = sin(ang);
            vec2 d = normalize(vec2(c * windDir.x - s * windDir.y, s * windDir.x + c * windDir.y));
            float a = amp0 * pow(gain, fi);
            float phi = k * dot(d, p) - omega * (timeScale * t) + fi * 1.234567;
            hg += a * sin(phi);
        }
        hg = sign(hg) * pow(abs(hg), mix(1.0, 0.65, clamp(peak, 0.0, 1.0)));
        h += 1 * hg; wSum += 1;
    }

    // Group B
    {
        const int OCT = 6;
        float amp0 = 0.25; float lambda0 = 6;
        float lacunarity = 0.5; float gain = 0.7;
        vec2 windDir = normalize(vec2(0.6427876096865394, 0.766044443118978));
        float dirJitter = 0.22; float timeScale = 1.4;
        float peak = 0.07; float weight = 1;
        float hg = 0.0;
        for (int i = 0; i < OCT; ++i) {
            float fi = float(i);
            float lambda = lambda0 * pow(lacunarity, fi);
            float k = 2.0 * PI / max(lambda, 1e-5);
            float omega = sqrt(G * k);
            float ang = fi * GOLD * dirJitter + 0.7;
            float c = cos(ang), s = sin(ang);
            vec2 d = normalize(vec2(c * windDir.x - s * windDir.y, s * windDir.x + c * windDir.y));
            float a = amp0 * pow(gain, fi);
            float phi = k * dot(d, p) - omega * (timeScale * t) + fi * 2.234567;
            hg += a * sin(phi);
        }
        hg = sign(hg) * pow(abs(hg), mix(1.0, 0.65, clamp(peak, 0.0, 1.0)));
        h += 1 * hg; wSum += 1;
    }

    // Group C
    {
        const int OCT = 3;
        float amp0 = 0.28; float lambda0 = 260;
        float lacunarity = 0.6; float gain = 0.55;
        vec2 windDir = normalize(vec2(-0.4999999999999998, 0.8660254037844387));
        float dirJitter = 0.35; float timeScale = 0.55;
        float peak = 0.1; float weight = 0.7;
        float hg = 0.0;
        for (int i = 0; i < OCT; ++i) {
            float fi = float(i);
            float lambda = lambda0 * pow(lacunarity, fi);
            float k = 2.0 * PI / max(lambda, 1e-5);
            float omega = sqrt(G * k);
            float ang = fi * GOLD * dirJitter + 1.4;
            float c = cos(ang), s = sin(ang);
            vec2 d = normalize(vec2(c * windDir.x - s * windDir.y, s * windDir.x + c * windDir.y));
            float a = amp0 * pow(gain, fi);
            float phi = k * dot(d, p) - omega * (timeScale * t) + fi * 3.234567;
            hg += a * sin(phi);
        }
        hg = sign(hg) * pow(abs(hg), mix(1.0, 0.65, clamp(peak, 0.0, 1.0)));
        h += 0.0 * hg; wSum += 0.0;
    }

    return (wSum > 0.0 ? h / wSum : 0.0);
}

// Autogenerated by Ocean Waves Param Explorer
// Composite ocean height  paste into your GLSL
float waves_combo_1(float x, float y, float t)
{
    const float PI = 3.14159265358979323846;
    const float G = 9.81;
    const float GOLD = 2.399963229728653;
    vec2 p = vec2(x, y);
    float h = 0.0; float wSum = 0.0;

    // Group A
    {
        const int OCT = 5;
        float amp0 = 0.6; float lambda0 = 131;
        float lacunarity = 0.55; float gain = 0.72;
        vec2 windDir = normalize(vec2(0.9659258262890683, 0.25881904510252074));
        float dirJitter = 0.77; float timeScale = 0.6;
        float peak = 0.64; float weight = 1;
        float hg = 0.0;
        for (int i = 0; i < OCT; ++i) {
            float fi = float(i);
            float lambda = lambda0 * pow(lacunarity, fi);
            float k = 2.0 * PI / max(lambda, 1e-5);
            float omega = sqrt(G * k);
            float ang = fi * GOLD * dirJitter + 0.0;
            float c = cos(ang), s = sin(ang);
            vec2 d = normalize(vec2(c * windDir.x - s * windDir.y, s * windDir.x + c * windDir.y));
            float a = amp0 * pow(gain, fi);
            float phi = k * dot(d, p) - omega * (timeScale * t) + fi * 1.234567;
            hg += a * sin(phi);
        }
        hg = sign(hg) * pow(abs(hg), mix(1.0, 0.65, clamp(peak, 0.0, 1.0)));
        h += 1 * hg; wSum += 1;
    }

    // Group B
    {
        const int OCT = 6;
        float amp0 = 0.25; float lambda0 = 6;
        float lacunarity = 0.5; float gain = 0.7;
        vec2 windDir = normalize(vec2(0.6427876096865394, 0.766044443118978));
        float dirJitter = 0.22; float timeScale = 1.4;
        float peak = 0.07; float weight = 1;
        float hg = 0.0;
        for (int i = 0; i < OCT; ++i) {
            float fi = float(i);
            float lambda = lambda0 * pow(lacunarity, fi);
            float k = 2.0 * PI / max(lambda, 1e-5);
            float omega = sqrt(G * k);
            float ang = fi * GOLD * dirJitter + 0.7;
            float c = cos(ang), s = sin(ang);
            vec2 d = normalize(vec2(c * windDir.x - s * windDir.y, s * windDir.x + c * windDir.y));
            float a = amp0 * pow(gain, fi);
            float phi = k * dot(d, p) - omega * (timeScale * t) + fi * 2.234567;
            hg += a * sin(phi);
        }
        hg = sign(hg) * pow(abs(hg), mix(1.0, 0.65, clamp(peak, 0.0, 1.0)));
        h += 1 * hg; wSum += 1;
    }

    // Group C
    {
        const int OCT = 3;
        float amp0 = 0.28; float lambda0 = 260;
        float lacunarity = 0.6; float gain = 0.55;
        vec2 windDir = normalize(vec2(-0.4999999999999998, 0.8660254037844387));
        float dirJitter = 0.35; float timeScale = 0.55;
        float peak = 0.1; float weight = 0.7;
        float hg = 0.0;
        for (int i = 0; i < OCT; ++i) {
            float fi = float(i);
            float lambda = lambda0 * pow(lacunarity, fi);
            float k = 2.0 * PI / max(lambda, 1e-5);
            float omega = sqrt(G * k);
            float ang = fi * GOLD * dirJitter + 1.4;
            float c = cos(ang), s = sin(ang);
            vec2 d = normalize(vec2(c * windDir.x - s * windDir.y, s * windDir.x + c * windDir.y));
            float a = amp0 * pow(gain, fi);
            float phi = k * dot(d, p) - omega * (timeScale * t) + fi * 3.234567;
            hg += a * sin(phi);
        }
        hg = sign(hg) * pow(abs(hg), mix(1.0, 0.65, clamp(peak, 0.0, 1.0)));
        h += 0.0 * hg; wSum += 0.0;
    }

    return (wSum > 0.0 ? h / wSum : 0.0);
}

// Auto-generated by Ocean Waves Param Explorer
// Composite ocean height - paste into your GLSL
float waves_combo_2(float x, float y, float t)
{
    const float PI = 3.14159265358979323846;
    const float G = 9.81;
    const float GOLD = 2.399963229728653;
    vec2 p = vec2(x, y);
    float h = 0.0; float wSum = 0.0;

    // Group A
    {
        const int OCT = 5;
        float amp0 = 0.6; float lambda0 = 310;
        float lacunarity = 0.55; float gain = 0.82;
        vec2 windDir = normalize(vec2(0.9659258262890683, 0.25881904510252074));
        float dirJitter = 0.94; float timeScale = 0.6;
        float peak = 0.16; float weight = 1;
        float hg = 0.0;
        for (int i = 0; i < OCT; ++i) {
            float fi = float(i);
            float lambda = lambda0 * pow(lacunarity, fi);
            float k = 2.0 * PI / max(lambda, 1e-5);
            float omega = sqrt(G * k);
            float ang = fi * GOLD * dirJitter + 0.0;
            float c = cos(ang), s = sin(ang);
            vec2 d = normalize(vec2(c * windDir.x - s * windDir.y, s * windDir.x + c * windDir.y));
            float a = amp0 * pow(gain, fi);
            float phi = k * dot(d, p) - omega * (timeScale * t) + fi * 1.234567;
            hg += a * sin(phi);
        }
        hg = sign(hg) * pow(abs(hg), mix(1.0, 0.65, clamp(peak, 0.0, 1.0)));
        h += 1 * hg; wSum += 1;
    }

    // Group B
    {
        const int OCT = 6;
        float amp0 = 0.25; float lambda0 = 28;
        float lacunarity = 0.5; float gain = 0.7;
        vec2 windDir = normalize(vec2(0.6427876096865394, 0.766044443118978));
        float dirJitter = 0.04; float timeScale = 1.4;
        float peak = 0.35; float weight = 1;
        float hg = 0.0;
        for (int i = 0; i < OCT; ++i) {
            float fi = float(i);
            float lambda = lambda0 * pow(lacunarity, fi);
            float k = 2.0 * PI / max(lambda, 1e-5);
            float omega = sqrt(G * k);
            float ang = fi * GOLD * dirJitter + 0.7;
            float c = cos(ang), s = sin(ang);
            vec2 d = normalize(vec2(c * windDir.x - s * windDir.y, s * windDir.x + c * windDir.y));
            float a = amp0 * pow(gain, fi);
            float phi = k * dot(d, p) - omega * (timeScale * t) + fi * 2.234567;
            hg += a * sin(phi);
        }
        hg = sign(hg) * pow(abs(hg), mix(1.0, 0.65, clamp(peak, 0.0, 1.0)));
        h += 1 * hg; wSum += 1;
    }

    // Group C
    {
        const int OCT = 7;
        float amp0 = 0.18; float lambda0 = 227;
        float lacunarity = 0.6; float gain = 0.84;
        vec2 windDir = normalize(vec2(-0.3420201433256687, 0.9396926207859084));
        float dirJitter = 0.2; float timeScale = 0.45;
        float peak = 0.54; float weight = 0.7;
        float hg = 0.0;
        for (int i = 0; i < OCT; ++i) {
            float fi = float(i);
            float lambda = lambda0 * pow(lacunarity, fi);
            float k = 2.0 * PI / max(lambda, 1e-5);
            float omega = sqrt(G * k);
            float ang = fi * GOLD * dirJitter + 1.4;
            float c = cos(ang), s = sin(ang);
            vec2 d = normalize(vec2(c * windDir.x - s * windDir.y, s * windDir.x + c * windDir.y));
            float a = amp0 * pow(gain, fi);
            float phi = k * dot(d, p) - omega * (timeScale * t) + fi * 3.234567;
            hg += a * sin(phi);
        }
        hg = sign(hg) * pow(abs(hg), mix(1.0, 0.65, clamp(peak, 0.0, 1.0)));
        h += 0.7 * hg; wSum += 0.7;
    }

    return (wSum > 0.0 ? h / wSum : 0.0);
}

// Auto-generated by Ocean Waves Param Explorer
// Composite ocean height - paste into your GLSL
float waves_combo_3(float x, float y, float t)
{
    const float PI = 3.14159265358979323846;
    const float G = 9.81;
    const float GOLD = 2.399963229728653;
    vec2 p = vec2(x, y);
    float h = 0.0; float wSum = 0.0;

    // Group A
    {
        const int OCT = 5;
        float amp0 = 0.6; float lambda0 = 310;
        float lacunarity = 0.55; float gain = 0.82;
        vec2 windDir = normalize(vec2(0.9659258262890683, 0.25881904510252074));
        float dirJitter = 0.94; float timeScale = 0.6;
        float peak = 0.16; float weight = 1;
        float hg = 0.0;
        for (int i = 0; i < OCT; ++i) {
            float fi = float(i);
            float lambda = lambda0 * pow(lacunarity, fi);
            float k = 2.0 * PI / max(lambda, 1e-5);
            float omega = sqrt(G * k);
            float ang = fi * GOLD * dirJitter + 0.0;
            float c = cos(ang), s = sin(ang);
            vec2 d = normalize(vec2(c * windDir.x - s * windDir.y, s * windDir.x + c * windDir.y));
            float a = amp0 * pow(gain, fi);
            float phi = k * dot(d, p) - omega * (timeScale * t) + fi * 1.234567;
            hg += a * sin(phi);
        }
        hg = sign(hg) * pow(abs(hg), mix(1.0, 0.65, clamp(peak, 0.0, 1.0)));
        h += 1 * hg; wSum += 1;
    }

    // Group B
    {
        const int OCT = 7;
        float amp0 = 0.25; float lambda0 = 28;
        float lacunarity = 0.5; float gain = 0.52;
        vec2 windDir = normalize(vec2(0.6427876096865394, 0.766044443118978));
        float dirJitter = 0.04; float timeScale = 1.4;
        float peak = 0.79; float weight = 1;
        float hg = 0.0;
        for (int i = 0; i < OCT; ++i) {
            float fi = float(i);
            float lambda = lambda0 * pow(lacunarity, fi);
            float k = 2.0 * PI / max(lambda, 1e-5);
            float omega = sqrt(G * k);
            float ang = fi * GOLD * dirJitter + 0.7;
            float c = cos(ang), s = sin(ang);
            vec2 d = normalize(vec2(c * windDir.x - s * windDir.y, s * windDir.x + c * windDir.y));
            float a = amp0 * pow(gain, fi);
            float phi = k * dot(d, p) - omega * (timeScale * t) + fi * 2.234567;
            hg += a * sin(phi);
        }
        hg = sign(hg) * pow(abs(hg), mix(1.0, 0.65, clamp(peak, 0.0, 1.0)));
        h += 1 * hg; wSum += 1;
    }

    // Group C
    {
        const int OCT = 2;
        float amp0 = 0.18; float lambda0 = 174;
        float lacunarity = 0.6; float gain = 0.48;
        vec2 windDir = normalize(vec2(-0.3420201433256687, 0.9396926207859084));
        float dirJitter = 0.66; float timeScale = 0.45;
        float peak = 0.2; float weight = 0.7;
        float hg = 0.0;
        for (int i = 0; i < OCT; ++i) {
            float fi = float(i);
            float lambda = lambda0 * pow(lacunarity, fi);
            float k = 2.0 * PI / max(lambda, 1e-5);
            float omega = sqrt(G * k);
            float ang = fi * GOLD * dirJitter + 1.4;
            float c = cos(ang), s = sin(ang);
            vec2 d = normalize(vec2(c * windDir.x - s * windDir.y, s * windDir.x + c * windDir.y));
            float a = amp0 * pow(gain, fi);
            float phi = k * dot(d, p) - omega * (timeScale * t) + fi * 3.234567;
            hg += a * sin(phi);
        }
        hg = sign(hg) * pow(abs(hg), mix(1.0, 0.65, clamp(peak, 0.0, 1.0)));
        h += 0.7 * hg; wSum += 0.7;
    }

    return (wSum > 0.0 ? h / wSum : 0.0);
}



// --- lightweight 2D value noise + fBM for color variation -------------------
// fast hash -> 0..1 (IQ-style)
float hash12(vec2 p) {
    vec3 p3 = fract(vec3(p.xyx) * 0.1031);
    p3 += dot(p3, p3.yzx + 33.33);
    return fract((p3.x + p3.y) * p3.z);
}

// smooth value noise 2D
float noise2(vec2 p) {
    vec2 i = floor(p);
    vec2 f = fract(p);
    vec2 u = f * f * (3.0 - 2.0 * f);

    float a = hash12(i + vec2(0.0, 0.0));
    float b = hash12(i + vec2(1.0, 0.0));
    float c = hash12(i + vec2(0.0, 1.0));
    float d = hash12(i + vec2(1.0, 1.0));

    return mix(mix(a, b, u.x), mix(c, d, u.x), u.y);
}

// fBM with small animation drift (cheap: 4 octaves by default)
float fbm2(vec2 p, float t, int octaves) {
    float sum = 0.0;
    float amp = 0.5;
    float freq = 1.0;

    // tiny movement so the tint breathes with time
    vec2 flow = vec2(0.6, 0.25) * t;

    for (int i = 0; i < octaves; ++i) {
        sum += amp * noise2(p * freq + flow);
        freq *= 2.0;
        amp *= 0.5;
    }
    return sum; // ~[0..1] if octaves not huge
}

// final mask tuned for ocean color variation (includes mild domain warp)
float oceanColorMask(vec2 xz, float t) {
    // base scale (bigger => broader patches)
    float baseScale = 0.08;             // tweak: 0.04 (large) .. 0.2 (small)
    vec2 p = xz * baseScale;

    // mild domain warp (cheap)
    float w1 = noise2(p + vec2(5.2, 1.3) + 0.15 * t);
    float w2 = noise2(p + vec2(1.7, 9.2) - 0.10 * t);
    p += 0.35 * vec2(w1, w2);

    // two-layer fBM for richer range
    float n = 0.65 * fbm2(p, t * 0.5, 4) + 0.35 * fbm2(p * 2.3, -t * 0.7, 3);

    // curve -> more contrast but keep it gentle
    n = smoothstep(0.35, 0.75, n);      // 0..1
    return n;
}

// Combine your four combos exactly like your wave_offset (reuse everywhere)
float oceanHeightCombined(vec2 p, float t) {
    float h = 0.0;
    h += waves_combo_0(p.x, p.y, -t) * 0.2;
    h += waves_combo_1(p.x, p.y, -t * 1.234) * 0.1;
    h += waves_combo_2(p.x, p.y, -t * 1.234);
    h += waves_combo_3(p.x, p.y, -t * 1.234);
    return h;
}

// Slope-based foam mask using two forward differences (fast)
// Tunables are inside for convenience.
float foamMaskFromHeight(vec2 p, float t, float h0) {
    // ---- tunables ----
    float epsWorld = 0.75;  // sampling step in world units (raise if too noisy)
    float slopeMin = 0.8;   // slope where foam starts
    float slopeMax = 2.2;   // slope where foam saturates
    float crestBoost = 0.25;  // extra boost on crests (0..1)
    // -------------------

    // finite differences (reuse h0 to avoid one call)
    float hx = oceanHeightCombined(p + vec2(epsWorld, 0.0), t) - h0;
    float hy = oceanHeightCombined(p + vec2(0.0, epsWorld), t) - h0;
    float slope = length(vec2(hx, hy)) / max(epsWorld, 1e-4);

    // bias foam toward crests a bit (positive height)
    float crest = smoothstep(0.0, 0.6, h0);
    float foam = smoothstep(slopeMin, slopeMax, slope);
    foam = clamp(mix(foam, foam * 1.5, crestBoost * crest), 0.0, 1.0);
    return foam;
}


void main()
{
    int id = gl_InstanceID;
    const int number_per_dimension = 1000;
    id = id + (number_per_dimension * number_per_dimension) * int(uDrawcallNumber);



    // Per-instance randomness
    uint s0 = uSeed + uint(id + 0);
    uint s1 = uSeed + uint(id + 42);
    float rnd_x = rand01(s0);
    float rnd_y = rand01(s1);

    uint s0_rot_x = uSeed + uint(id + 2431);
    uint s1_rot_y = uSeed + uint(id + 4412);
    uint s2_rot_y = uSeed + uint(id + 1234);
    uint s3_rot_angle = uSeed + uint(id + 2332);

    float rnd_cube_rotation_x = rand01(s0_rot_x);
    float rnd_cube_rotation_y = rand01(s1_rot_y);
    float rnd_cube_rotation_z = rand01(s2_rot_y);
    float rnd_cube_rotation_angle = rand01(s3_rot_angle);


    // Position on sphere



    // float radius_offset = 0.2 * sin(rnd_x * TAU * 10.0) + 0.02 * sin(rnd_y * 20 * TAU + uTime * 1.0);


    // float radius = 4.0 + radius_offset;
   //  vec3 sphere_position = spherical01(radius, rnd_x, rnd_y);
    float px = rnd_y * 100.0;// sphere_position.x;
    float py = rnd_x * 100.0;// sphere_position.y;
    float pz = 0.0;//sphere_position.z;

    float color_r = 1.0;
    float color_g = 1.0;
    float color_b = 1.0;

    float wave_0 = waves_combo_0(px, py, -uTime);
    float wave_1 = waves_combo_1(px, py, -uTime * 1.234);
    float wave_2 = waves_combo_2(px, py, -uTime * 1.234);
    float wave_3 = waves_combo_3(px, py, -uTime * 1.234);
    
    float wave_offset = 0.0;
    wave_offset += wave_0 * 0.2;
    wave_offset += wave_1 * 0.1;
    wave_offset += wave_2;
    wave_offset += wave_3;
    
    
    pz += wave_offset;

    vec3 color_base_dark = vec3(0.02, 0.08, 0.15);
    vec3 color_base_bright = vec3(0.10, 0.50, 0.75);


    vec3 color_base = mix(color_base_dark, color_base_bright, min(max(0.0, wave_offset), 1.0));

    {
        // --- Per-instance color jitter (stable; zero-mean-ish) ----------------------
        uint sJ = (uSeed ^ uint(id)) * 2654435761u;   // golden-ratio hash
        float j0 = rand01(sJ);                        // hue-ish
        float j1 = rand01(sJ);                        // direction mix
        float j2 = rand01(sJ);                        // value (brightness)

        // two chroma directions roughly orthogonal to gray axis
        vec3 b1 = normalize(vec3(1.0, -1.0, 0.0));
        vec3 b2 = normalize(vec3(1.0, 1.0, -2.0));
        vec3 jitterDir = normalize(mix(b1, b2, j1));

        // small tint swing ±0.12 in “hue-ish” direction
        float hueSwing = (j0 - 0.5) * 0.24;
        vec3  jitterTint = hueSwing * jitterDir;

        // small value swing ±9%, gated by foam so crests stay clean
        float valSwing = (j2 - 0.5) * 0.18;
        float foamGate = 1.0; // replace with `mix(1.0, 0.6, foam)` once foam is computed

        vec3 color_per_instance = clamp((color_base + jitterTint * foamGate) * (1.0 + valSwing * foamGate),0.0, 1.0);
        color_base = color_base + 1.0 * (color_base * abs(sin(color_per_instance * color_base + vec3(uTime + rnd_x * 100.0 * rnd_y* 100.0 + wave_offset * 100.00))));
        
    }

    //// Perlin/fBM mask in world space (matches your px,py domain)
    //float nMask = oceanColorMask(vec2(px, py), -uTime);

    //// Subtle hue/brightness modulation (no new uniforms)
    //vec3 coolTint = vec3(0.00, 0.03, 0.05);  // deeper, cooler pockets
    //vec3 warmTint = vec3(0.06, 0.07, 0.02);  // sunlit greenish-cyan flecks

    //// apply tints and a tiny contrast kick; keep it conservative for albedo
    //color_base += mix(coolTint, warmTint, nMask) * 0.6;   // tint shift
    //color_base *= (0.92 + 0.16 * nMask);                  // micro-contrast

    //// safety: clamp albedo
    //color_base = clamp(color_base, 0.0, 1.0);

    // foam from slope of the combined height field
    float foam = foamMaskFromHeight(vec2(px, py), uTime, wave_offset);

    

    // (optional) keep the noise tint you added earlier
    // float nMask = oceanColorMask(vec2(px,py), uTime);
    // color_base += mix(vec3(0.00,0.03,0.05), vec3(0.06,0.07,0.02), nMask) * 0.6;
    // color_base *= (0.92 + 0.16 * nMask * 1.0);
    {
        // --- Foam-aware, zero-mean tint with gentle S-curve -----------------
        float n = oceanColorMask(vec2(px, py), uTime);   // 0..1
        float m = (n - 0.5) * 2.0;                      // -> [-1..1]
        m *= (1.0 + 0.25 * m * m);                       // push extremes a bit (S-curve)

        // Optional foam gating (keeps white crests clean); if you have foam:
        float foam = foamMaskFromHeight(vec2(px, py), uTime, wave_offset);
        float gate = mix(1.0, 0.4, foam);                // 0.4 = reduce tint on foam

        // cool vs warm tint directions (keep small!)
        vec3 cool = vec3(0.00, 0.03, 0.06);              // bluish deep pockets
        vec3 warm = vec3(0.06, 0.07, 0.02);              // greenish-cyan flecks

        float strength = 0.35 * gate;                    // overall tint amount

        // add tint symmetrically: warm for m>0, cool for m<0 (zero-mean)
        color_base += (warm * max(m, 0.0)
            - cool * max(-m, 0.0)) * strength;

        // tiny contrast around 1.0 that won’t bias average brightness
        color_base *= (1.0 + 0.10 * m);

        // safety
        color_base = clamp(color_base, 0.0, 1.0);
    }

     // foam-aware whitening (albedo-safe)
    color_base = mix(color_base, vec3(1.0), foam * 0.85);

    // safety
    color_base = clamp(color_base, 0.0, 1.0);

    {
        // --- High-frequency details (world-anchored) --------------------------------
        // tiny animated fBM modulation (uses your noise2/fbm2 helpers)
        float hf = fbm2(vec2(px, py) * 2.0 + vec2(0.20 * uTime, -0.17 * uTime), 0.0, 3);
        hf = (hf - 0.5);                              // [-0.5..0.5] -> symmetric
        color_base *= (1.0 + 0.10 * hf * (1.0 - 0.7 * foam)); // less on foam

        // rare speckles (grid-quantized -> stable, less shimmer)
        float cellScale = 6.0;                         // higher = smaller cells, more specks
        vec2 cell = floor(vec2(px, py) * cellScale);
        float spex = hash12(cell + vec2(13.37 * float(id), 7.91 * float(id)));
        float speck = step(0.992, spex);               // ~0.8% of cells hit
        color_base = mix(color_base, vec3(1.0), speck * 0.12 * (1.0 - foam)); // avoid on foam
    }

    // your existing write-out
    color_r = color_base.r * 2.0;
    color_g = color_base.g * 2.0;
    color_b = color_base.b * 2.0;




   

    
    

    


    // Instance transform (tiny cubes, uniform scale)
    float interactive = 1.0;
    float rendering = 0.1;

    float scale_cube = 0.01 * 0.7 * 2.0 * 2.0 * 2.0 * 0.4 * 0.1 * 2.0 * 1.0 * rendering;
    vec3  pos = vec3(px, pz, py);
    vec3  scale = vec3(scale_cube, scale_cube * 1000.0, scale_cube);

    
    

    

    float x = float(id / 1000);
    float y = float(id % 1000) * 0.01;
    float z = float(id) * 0.1;


    uint s0n = uSeed + uint(id + 10);
    uint s1n = uSeed + uint(id + 142);
    float rnd_xn = rand01(s0n);
    float rnd_yn = rand01(s1n);




    // pos.x = x * 0.01;
    // pos.y = 0.0;
    // pos.z = y;
    // The output color

   // float factor_radius_offset = pow(max(0.0, radius_offset), 4.0) * 10.0;


    //float color_r = px + sin(radius * 10.0);
    ///float color_g = py + factor_radius_offset * 100.0;
    // float color_b = pz;

  // color_r *= 0.1;
  // color_g *= 0.1;
  // color_b *= 0.1;
  



    vec4 new_position = vec4(vec3(pos), 1.0);

    if(false){

        uint s0_instance_0 = uSeed + uint(uint(u0 * 1000.0f));
        uint s0_instance_1 = uSeed + uint(uint(u0 * 1421.0f));
        float rnd_instance_0 = rand01(s0_instance_0);
        float rnd_instance_1 = rand01(s0_instance_1);

        uint s0_instance_x_scale = uSeed + uint(uint(u0 * 14024.0f));
        uint s0_instance_y_scale = uSeed + uint(uint(u0 * 15214.0f));
        uint s0_instance_z_scale = uSeed + uint(uint(u0 * 14215.0f));
        float rnd_instance_scale_x = rand01(s0_instance_x_scale);
        float rnd_instance_scale_y = rand01(s0_instance_y_scale);
        float rnd_instance_scale_z = rand01(s0_instance_z_scale);


        vec3 axis = normalize(vec3(1.0, 1.0, 0.0));
        float angle = uTime;
        mat3 R3 = axisAngleToMat3(axis, angle);
        mat4 R = mat4(vec4(R3[0], 0.0), vec4(R3[1], 0.0), vec4(R3[2], 0.0), vec4(0, 0, 0, 1));



        mat4 T = mat4(1.0);

        vec3 offset = vec3(sin(uTime + rnd_instance_0 * 10.0) * 10.0, sin(uTime + rnd_instance_1 * 0.0) * 10.0, 0.0);
        T[3] = vec4(offset, 1.0);


        mat4 S = mat4(1.0);
        S[0][0] = 1.0;
        S[1][1] = 1.0;
        S[2][2] = 2.0 + 1.0 * sin(uTime + rnd_instance_scale_z * 10.0);

        new_position = T * R * S * new_position;
    }



    pos = new_position.xyz;




    // Per-instance tint (kept neutral here)
    color_vs = vec3(color_r, color_g, color_b);

    // Build TRS
    mat4 T = mat4(1.0); T[3] = vec4(pos, 1.0);
    vec3 axis = normalize(vec3(rnd_cube_rotation_x, rnd_cube_rotation_y, rnd_cube_rotation_z));
    float angle = rnd_cube_rotation_angle;//uTime * 0.0;
    mat3 R3 = axisAngleToMat3(axis, angle);
    mat4 R = mat4(vec4(R3[0], 0.0), vec4(R3[1], 0.0), vec4(R3[2], 0.0), vec4(0, 0, 0, 1));
    mat4 S = mat4(1.0); S[0][0] = scale.x; S[1][1] = scale.y; S[2][2] = scale.z;

    mat4 instanceModel = T * R * S;
    mat4 M = model * instanceModel;

    // World-space position (for lighting)
    vec4 wp = M * vec4(aPos, 1.0);
    vWorldPos = wp.xyz;

    // World-space normal:
    // Fast path (assumes uniform scale): rotate the face normal by model rotation and R3.
    // If you later use non-uniform model scale, switch to normal matrix:
    //   mat3 N = transpose(inverse(mat3(M)));
    //   vNormal = normalize(N * nLocal);
    vec3 nLocal = localCubeFaceNormal(aPos);
    vNormal = normalize(mat3(model) * (R3 * nLocal)); // uniform-scale assumption

    // Clip-space position and UV
    gl_Position = projection * view * wp;
    TexCoord = aTexCoord;


    // World position color

    // float world_x = wp.x;
    // float world_y = wp.y;
    // float world_z = wp.z;
    // color_vs = vec3(sin(world_x * 10.0), sin(world_y * 10.0), sin(world_z * 10.0));
}



